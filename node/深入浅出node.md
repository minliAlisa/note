[TOC]

# 深入浅出node.js

### 第一章 Node简介

#### 1.1 node给javascript带来的意义：

javascipt只限制在chrome浏览器中运行，它的能力取决于浏览器中间层提供的支持。

![image-20190123181015047](https://ws2.sinaimg.cn/large/006tNc79ly1fzhhecy5bcj30gk08qmxx.jpg)



node 的结构与chrome十分相似。它们都是基于事件驱动的异步架构，浏览器是通过事件驱动来服务界面上的交互，Node是通过事件驱动来服务I/O。在node中，javascript 可以随心所欲的访问本地文件，可以搭建websocket服务器端，可以连接数据库，可以进行多线程。

##### node打破了JavaScript只能在浏览器中运行的局面，前后端编程环境统一，可以降低前后端转化所需要的上下文交换代价。

#### 1.2 node的特点：

#####(1) 异步I/O：

一个我们常见的ajax请求：

```javascript
$.post('/url', {title: '深入浅出node.js'}, function(data) {
    console.log('收到响应')
})；
console.log('发送ajax结束')；
```

​	图一：经典的异步io

![image-20190123191124505](https://ws4.sinaimg.cn/large/006tNc79ly1fzhhedmog5j30gq0fcmxr.jpg)

​	node中的异步io也很常见， 以读取文件为例，与ajax的调用方式非常类似：

```javascript
var fs = require('fs');

fs.readFile('/path', function(err, file) {
    console.log('读取文件完成')
})；

console.log('发起读取文件')；
```



![image-20190123191904800](https://ws1.sinaimg.cn/large/006tNc79ly1fzhhee86ohj30gu0er74w.jpg)

在node中，大部分的操作都是异步的方式进行的。并且可以进行并行I/O操作。每个调用之间不用等待之前的I/O调用结束。 

 两个同时进行的异步任务的耗时，取决于最慢的那个任务的耗时：

```
fs.readFile('path1',function(err, file) {
    console.log(’读取文件1完成‘)；
})
fs.readFile('path2', function(err, file) {
    console.log('读取文件2完成')；
})
```

而同步I/O进行的两个任务，它们的耗时是两个任务的耗时之和。

##### (2) node是单线程： 

node保持了javascript在浏览器中单线程的特点，在node中javascript与其余线程是无法共享任何状态的。关于单线程：

​	-- 优点:  不用处处在意状态的同步问题， 不存在死锁的问题，也没有线程上下文交换带来的性能开销。

​	-- 缺点：无法利用多核CPU；错误会引起整个应用的退出，应用的健壮性值得考量；大量的计算占用CPU导致无法继续调用异步I/O。

 为了解决单线程会阻塞主线程事件的进行，采用了与webWorkers相同的思路： child_process。即创建多个子进程。

#### 1.3 node的应用场景：

##### （1）I/O密集型：

 I/O密集的主要优势在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。

##### （2）是否不擅长CPU密集型：

 实际上，V8的执行效率是非常高的。

CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU。

###### Node 可以被使用，只是需要合理的调度。将大型占用CPU计算的任务，进行拆解成小的任务。使占用CPU的计算不影响后续I/O调用的发起。

#### 1.4 node的使用者：

##### （1）前后端语言环境统一：

##### （2）node带来的高性能I/O用于实时应用：

##### （3）并行I/O使得使用者可以更高效地利用分布式环境：

##### （4）并行I/O，有效利用稳定接口提升Web渲染能力：

##### （5）云计算平台提供Node支持：

##### （6）游戏开发领域：

##### （7）工具类应用：

### 第二章 模块机制

#### 2.1 ComminJs规范

#####  2.1.1出发点：

###### 对于官方规范ECMAScript,规范化时间较早，涵盖范畴小，对于js来说比较薄弱，仍有以下缺点：

###### 	(1)没有模块系统

###### 	(2)标准库较少。

######         (3)没有标准接口。

######  	(4)缺乏包管理系统。

![image-20190124144213163](https://ws2.sinaimg.cn/large/006tNc79ly1fzhoqqcnm2j30gy05agm5.jpg)

##### 2.1.2 CommonJs规范：

###### CommonJs对模块的定义非常简单，主要分为模块引用、模块定义和模块标识三个部分。

###### （1）模块引用：

require()方法作为接受模块的标识，以此引入一个模块的api到当前上下文中。模块引用的示例代码如下：

```javascript
var math = require('math');
```

###### （2）模块定义：

require()作为模块上下文中引入的方法， 也对应的提供了exports对象作为导出当前模块或者变量的方法 。在模块中还存在一个module对象，它代表模块自身，而exports是module的属性。在node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方法。

```javascript
//math.js
export.add = function() {
  var sum = 0,
  	i = 0,
  	args = arguments,
  	l = args.length;
  while (i < l) {
    sum += args[i++];
  };
  return sum;
};
```

在另一个文件中， 我们可以通过require()方法引入。就可以调用定义的属性或方法了。

```javascript
//program.js
var math = require('math');
exports.increment = function(val) {
  return math.add(val, 1);
};
```

###### (3) 模块标识：

模块标识其实就是传递给require()方法的参数，它必须是符合**小驼峰命名**的字符串，或者以. 、.. 开头的相对路径 或者绝对路径。它可以没有文件名后缀 .js。 

每个模块具有独立的空间，他们互相不干扰。可以不考虑变量污染等问题。

![image-20190124150237186](https://ws3.sinaimg.cn/large/006tNc79ly1fzhoqq59nfj30gk07274o.jpg)

#### 2.2 node的模块实现：

##### 2.2.1 node模块简述：

###### 1.在node引入模块，需要经历如下三个步骤：

（1）路径分析

（2）文件定位

（3）编译执行

###### 2.node中，模块主要分为两类：

(1) 一类是node提供的模块，称为**核心模块**；

**核心模块**部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的**加载速度是最快的**。

(2) 另一类是用户编写的模块，称为**文件模块**。

**文件模块**则是在运行时动态加载的，需要完整的路径分析、文件定位、编译执行过程，**速度比核心模块慢**。

###### 3.优先从缓存加载：

与前端浏览器会缓存静态资源以提高性能一样，node对引入的模块都会进行缓存，以减少二次引用时的开销，不同的是，浏览器仅仅缓存文件而node缓存的是编译和执行后的对象。

不论是核心模块还是文件模块，`require()`方法对相同模块的二次加载都一律采用缓存优先的方式，这是**第一优先级**的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

##### 2.2.2 路径分析和文件定位：

###### 1.模块标识符分析

（1）**核心模块**  — 加载最快

核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。

如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个`http`用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。

（2）**路径形式的文件模块**  — 加载稍慢

以.、..和/开始的标识符，这里都被当做文件模块来处理。在分析路径模块时，`require()`方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。

由于文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。

（3）**自定义模块**  — 加载最慢

自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。

###### 2.文件定位：

（1）文件扩展名分析：CommonJs模块规范，允许标识符中不包含文件扩展名。这种情况下，node会按照.js、.json、.node的次序依次补足扩展名，依次尝试。 由于尝试文件名时，会调用fs模块，会同步阻塞式的判断文件是否存在。所以，如果是node或者json文件，尽可能的在require时带上扩展名。

#### 2.3 AMD规范:

##### AMD规范是CommonJs模块规范的一个延伸，它的模块定义如下：?代表可选。

```amd
define(id?, dependencies?, factory)
```

factory的内容就是实际代码的内容，下面定义了一个简单的模块：

```amd
define(function() {
  var exports = {};
  exports.sayHello = function() {
    alert('Hello from module:'+module.id);
  };
  return exports;
});
```

#### 2.4 CMD规范：

##### CMD规范由国内的玉伯提出，与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：

```cmd
define(['dep1', 'dep2'], function (dep1, dep2) {
  return function() {};
});
```

### 第三章 异步I/O

#### 3.1 现实的异步I/O:

​	![image-20190125170857018](https://ws1.sinaimg.cn/large/006tNc79ly1fzj14nil83j30g00ai74v.jpg)

#### 3.2 node的异步I/O:

##### 3.2.1 node自身的执行模型 --- 事件循环。

在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。”“每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。

![image-20190125184928192](https://ws1.sinaimg.cn/large/006tNc79ly1fzj14mtgk0j30g00iv755.jpg)

##### 3.2.2 观察者

在node中，事件主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。

时间循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，源源不断为node提供不同的事件类型，这些事件被传递到对应的观察者那里，时间循环则从观察者那里取出事件并处理。

##### 3.2.3 请求对象

对于一般的（非异步）回调函数，函数由我们自行调用，

```javascript
var forEach = function (list, callback) {
  for (var i = 0; i < list.length; i++) {
    callback(list[i], i, list);
  }
}; 
```

对于node中的异步I/O调用而言，回调过程却不由开发者来调用。事实上，从javascript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，叫做请求对象。

#### 3.3 非I/O的异步API

node中存在一些与异步I/O无关的API，分别是 setTimeout() 、setInterval()、setImmediate()、process.nextTick()。

##### 3.3.1 定时器

setTimeout() 和setInterval() 与 浏览器中的API是一致的。分别用于单次和多次定时任务的执行。它们的实现原理与异步I/O比较类似，只是不需要I/O线程池的参与。setInterval()与之相同，区别在于后者是重复性的检测和执行。

![image-20190212142022751](/Users/finup/Library/Application Support/typora-user-images/image-20190212142022751.png)

##### 3.3.2 process.nextTick()

由于事件循环自身的特点，定时器的精度不够。事实上，采用定时器需要用到红黑树，创建定时器对象和迭代等操作。比较浪费性能。事实上 process.nextTick() 方法的操作较为轻量，每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick中取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效。

##### 3.3.3 setImmediate()

setImmediate()方法与process.nextTick() 方法十分类似，都是将回调函数延迟执行。

```no
process.nextTick(function () {
  console.log('nextTick延迟执行');
});
setImmediate(function () {
  console.log('setImmediate延迟执行');
});
console.log('正常执行');
```

其执行结果如下：

```
正常执行
nextTick延迟执行
setImmediate延迟执行
```

从结果可以看到， process.nextTick()中的回调函数执行的优先级要高于setImmediate()。这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idel观察者，setImmediate()属于check观察者。在每一个轮循环检查中idel观察者先与I/O观察者，I/O观察者先于check观察者。

#### 3.4  事件驱动与高性能服务器

![image-20190212144349792](/Users/finup/Library/Application Support/typora-user-images/image-20190212144349792.png)

下面是几种典型的服务器模型，这里对比下他们的优缺点。

（1）同步式。对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态。

（2）每进程/每请求。为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性因为系统资源只有那么多。

（3）每线程/每请求。为每个请求启动一个线程来处。尽管线程比进程要轻量，但是由于每个线程都占用一定的内存，当大量请求并发到来时，内存将会很快就耗光，导致服务器缓慢。

每线程/每请求的方式目前还被Apache所采用。Node通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是Node高性能的一个原因。

事件驱动带来的高效已经渐渐开始为业界所重视。知名服务器Nginx，也摒弃了多线程的方式，采用了和Node相同的事件驱动。如今，Nginx大有取代Apache之势。Node具有与Nginx相同的特性，不同之处在于Nginx采用纯C写成，性能较高，但是它仅适合于做Web服务器，用于反向代理或负载均衡等服务，在处理具体业务方面较为欠缺。Node则是一套高性能的平台，可以利用它构建与Nginx相同的功能，也可以处理各种具体业务，而且与背后的网络保持异步畅通。两者相比，Node没有Nginx在Web服务器方面那么专业，但场景更大，自身性能也不错。在实际项目中，我们可以结合它们各自优点，以达到应用的最优性能。
