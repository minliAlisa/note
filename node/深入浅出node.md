[TOC]

# 深入浅出node.js

### 第一章 Node简介

#### 1.1 node给javascript带来的意义：

javascipt只限制在chrome浏览器中运行，它的能力取决于浏览器中间层提供的支持。

![image-20190123181015047](https://ws2.sinaimg.cn/large/006tNc79ly1fzhhecy5bcj30gk08qmxx.jpg)



node 的结构与chrome十分相似。它们都是基于事件驱动的异步架构，浏览器是通过事件驱动来服务界面上的交互，Node是通过事件驱动来服务I/O。在node中，javascript 可以随心所欲的访问本地文件，可以搭建websocket服务器端，可以连接数据库，可以进行多线程。

##### node打破了JavaScript只能在浏览器中运行的局面，前后端编程环境统一，可以降低前后端转化所需要的上下文交换代价。

#### 1.2 node的特点：

#####(1) 异步I/O：

一个我们常见的ajax请求：

```javascript
$.post('/url', {title: '深入浅出node.js'}, function(data) {
    console.log('收到响应')
})；
console.log('发送ajax结束')；
```

​	图一：经典的异步io

![image-20190123191124505](https://ws4.sinaimg.cn/large/006tNc79ly1fzhhedmog5j30gq0fcmxr.jpg)

​	node中的异步io也很常见， 以读取文件为例，与ajax的调用方式非常类似：

```javascript
var fs = require('fs');

fs.readFile('/path', function(err, file) {
    console.log('读取文件完成')
})；

console.log('发起读取文件')；
```



![image-20190123191904800](https://ws1.sinaimg.cn/large/006tNc79ly1fzhhee86ohj30gu0er74w.jpg)

在node中，大部分的操作都是异步的方式进行的。并且可以进行并行I/O操作。每个调用之间不用等待之前的I/O调用结束。 

 两个同时进行的异步任务的耗时，取决于最慢的那个任务的耗时：

```
fs.readFile('path1',function(err, file) {
    console.log(’读取文件1完成‘)；
})
fs.readFile('path2', function(err, file) {
    console.log('读取文件2完成')；
})
```

而同步I/O进行的两个任务，它们的耗时是两个任务的耗时之和。

##### (2) node是单线程： 

node保持了javascript在浏览器中单线程的特点，在node中javascript与其余线程是无法共享任何状态的。关于单线程：

​	-- 优点:  不用处处在意状态的同步问题， 不存在死锁的问题，也没有线程上下文交换带来的性能开销。

​	-- 缺点：无法利用多核CPU；错误会引起整个应用的退出，应用的健壮性值得考量；大量的计算占用CPU导致无法继续调用异步I/O。

 为了解决单线程会阻塞主线程事件的进行，采用了与webWorkers相同的思路： child_process。即创建多个子进程。

#### 1.3 node的应用场景：

##### （1）I/O密集型：

 I/O密集的主要优势在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。

##### （2）是否不擅长CPU密集型：

 实际上，V8的执行效率是非常高的。

CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU。

###### Node 可以被使用，只是需要合理的调度。将大型占用CPU计算的任务，进行拆解成小的任务。使占用CPU的计算不影响后续I/O调用的发起。

#### 1.4 node的使用者：

##### （1）前后端语言环境统一：

##### （2）node带来的高性能I/O用于实时应用：

##### （3）并行I/O使得使用者可以更高效地利用分布式环境：

##### （4）并行I/O，有效利用稳定接口提升Web渲染能力：

##### （5）云计算平台提供Node支持：

##### （6）游戏开发领域：

##### （7）工具类应用：

### 第二章 模块机制

#### 2.1 ComminJs规范

#####  2.1.1出发点：

###### 对于官方规范ECMAScript,规范化时间较早，涵盖范畴小，对于js来说比较薄弱，仍有以下缺点：

###### 	(1)没有模块系统

###### 	(2)标准库较少。

######         (3)没有标准接口。

######  	(4)缺乏包管理系统。

![image-20190124144213163](https://ws2.sinaimg.cn/large/006tNc79ly1fzhoqqcnm2j30gy05agm5.jpg)

##### 2.1.2 CommonJs规范：

###### CommonJs对模块的定义非常简单，主要分为模块引用、模块定义和模块标识三个部分。

###### （1）模块引用：

require()方法作为接受模块的标识，以此引入一个模块的api到当前上下文中。模块引用的示例代码如下：

```javascript
var math = require('math');
```

###### （2）模块定义：

require()作为模块上下文中引入的方法， 也对应的提供了exports对象作为导出当前模块或者变量的方法 。在模块中还存在一个module对象，它代表模块自身，而exports是module的属性。在node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方法。

```javascript
//math.js
export.add = function() {
  var sum = 0,
  	i = 0,
  	args = arguments,
  	l = args.length;
  while (i < l) {
    sum += args[i++];
  };
  return sum;
};
```

在另一个文件中， 我们可以通过require()方法引入。就可以调用定义的属性或方法了。

```javascript
//program.js
var math = require('math');
exports.increment = function(val) {
  return math.add(val, 1);
};
```

###### (3) 模块标识：

模块标识其实就是传递给require()方法的参数，它必须是符合**小驼峰命名**的字符串，或者以. 、.. 开头的相对路径 或者绝对路径。它可以没有文件名后缀 .js。 

每个模块具有独立的空间，他们互相不干扰。可以不考虑变量污染等问题。

![image-20190124150237186](https://ws3.sinaimg.cn/large/006tNc79ly1fzhoqq59nfj30gk07274o.jpg)

#### 2.2 node的模块实现：

##### 2.2.1 node模块简述：

###### 1.在node引入模块，需要经历如下三个步骤：

（1）路径分析

（2）文件定位

（3）编译执行

###### 2.node中，模块主要分为两类：

(1) 一类是node提供的模块，称为**核心模块**；

**核心模块**部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的**加载速度是最快的**。

(2) 另一类是用户编写的模块，称为**文件模块**。

**文件模块**则是在运行时动态加载的，需要完整的路径分析、文件定位、编译执行过程，**速度比核心模块慢**。

###### 3.优先从缓存加载：

与前端浏览器会缓存静态资源以提高性能一样，node对引入的模块都会进行缓存，以减少二次引用时的开销，不同的是，浏览器仅仅缓存文件而node缓存的是编译和执行后的对象。

不论是核心模块还是文件模块，`require()`方法对相同模块的二次加载都一律采用缓存优先的方式，这是**第一优先级**的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

##### 2.2.2 路径分析和文件定位：

###### 1.模块标识符分析

（1）**核心模块**  — 加载最快

核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。

如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个`http`用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。

（2）**路径形式的文件模块**  — 加载稍慢

以.、..和/开始的标识符，这里都被当做文件模块来处理。在分析路径模块时，`require()`方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二次加载时更快。

由于文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块。

（3）**自定义模块**  — 加载最慢

自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。

###### 2.文件定位：

（1）文件扩展名分析：CommonJs模块规范，允许标识符中不包含文件扩展名。这种情况下，node会按照.js、.json、.node的次序依次补足扩展名，依次尝试。 由于尝试文件名时，会调用fs模块，会同步阻塞式的判断文件是否存在。所以，如果是node或者json文件，尽可能的在require时带上扩展名。

#### 2.3 AMD规范:

##### AMD规范是CommonJs模块规范的一个延伸，它的模块定义如下：?代表可选。

```amd
define(id?, dependencies?, factory)
```

factory的内容就是实际代码的内容，下面定义了一个简单的模块：

```amd
define(function() {
  var exports = {};
  exports.sayHello = function() {
    alert('Hello from module:'+module.id);
  };
  return exports;
});
```

#### 2.4 CMD规范：

##### CMD规范由国内的玉伯提出，与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：

```cmd
define(['dep1', 'dep2'], function (dep1, dep2) {
  return function() {};
});
```

### 第三章 异步I/O

#### 3.1 现实的异步I/O:

​	![image-20190125170857018](https://ws1.sinaimg.cn/large/006tNc79ly1fzj14nil83j30g00ai74v.jpg)

#### 3.2 node的异步I/O:

##### 3.2.1 node自身的执行模型 --- 事件循环。

在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。”“每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。

![image-20190125184928192](https://ws1.sinaimg.cn/large/006tNc79ly1fzj14mtgk0j30g00iv755.jpg)

##### 3.2.2 观察者

在node中，事件主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。

时间循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，源源不断为node提供不同的事件类型，这些事件被传递到对应的观察者那里，时间循环则从观察者那里取出事件并处理。

##### 3.2.3 请求对象

对于一般的（非异步）回调函数，函数由我们自行调用，

```javascript
var forEach = function (list, callback) {
  for (var i = 0; i < list.length; i++) {
    callback(list[i], i, list);
  }
}; 
```

对于node中的异步I/O调用而言，回调过程却不由开发者来调用。事实上，从javascript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，叫做请求对象。